input {
  redis {
    host => "securock_redis"
    port => 6379
    key => "logs_queue"
    data_type => "list"
    codec => "json"
  }
}

filter {
  # Add ECS metadata
  mutate {
    add_field => { "[ecs][version]" => "8.0.0" }
    rename => { "source_ip" => "[source][ip]" }
    rename => { "dest_ip" => "[destination][ip]" }
    rename => { "user" => "[user][name]" }
    rename => { "event_type" => "[event][action]" }
    rename => { "message" => "[message]" }
    rename => { "timestamp" => "@timestamp" }
  }

  # Example: Parse SSH logs if event action is SSH_LOGIN
  if [event][action] == "SSH_LOGIN" {
    grok {
      match => { "message" => "Accepted %{WORD:auth_method} for %{WORD:[user][name]} from %{IP:[source][ip]} port %{NUMBER:[source][port]}" }
    }
  }
}

output {
  opensearch {
    hosts => ["https://wazuh.indexer:9200"]
    user => "${OPENSEARCH_USER}"
    password => "${OPENSEARCH_PASSWORD}"
    index => "wazuh-alerts-3.x-%{+YYYY.MM.dd}"
    ssl => true
    ssl_certificate_verification => false
  }
  # Keep sending to Redis for WebSocket/Alerting if needed? 
  # For now, we assume the backend might query OpenSearch or we use a separate output.
}
